---
title:  "Pourquoi Docker ?"
categories: devops
---

<>{props.toc}</>

## Pour travailler ensmble
Tout le monde dÃ©veloppe sur diffÃ©rentes machines. Il n'est pas rare que plusieurs collÃ¨gues aient installÃ© diffÃ©rentes version d'une mÃªme library, d'un package manager, du runtime de leur application... (cc node/npm ğŸ‘‹)

Lorsque l'application de dÃ©veloppement est dockerisÃ©e, tous les devs (et la prod !) sont soumis aux mÃªmes rÃ¨gles, ce qui Ã©vite le syndrÃ´me de _"mais Ã§a marche sur mon PC"_ tout en rÃ©duisant la configuration nÃ©cessaire Ã  installer l'environnement de dev. Voir juste aprÃ¨s !

## Pour moins perdre de temps Ã  configurer
La configration, c'est du temps passÃ© Ã  ne pas Ãªtre productif. Plus une application doit Ãªtre capable de tourner dans diffÃ©rents environnements, plus de configuration doit Ãªtre faite. Docker permet d'abstraire l'environnement dans lequel tourne l'application et donc de ne faire que le minimum nÃ©cessaire.

Une consÃ©quence notable: pour ajouter un service Ã  la stack, plus forcÃ©ment besoin d'apprendre en dÃ©tails une technologie. Il suffit d'ajouter une image existante de celle-ci, et de simplement spÃ©cifier les variables d'environnement nÃ©cessaire. Par exemple, pour [ajouter une database PostgreSQL](https://hub.docker.com/_/postgres/), il suffit au minimum de renseigner un root password et de monter un volume pour persister les donnÃ©es.

## Pour sÃ©parer les problÃ¨mes
Comme chaque service est aussi simple que possible, chacun n'a que trÃ¨s peu de dÃ©pendances avec le reste du monde. On voit que, par nature, les conteneurs nous poussent Ã  n'avoir que le minimum vital de dÃ©pendances entre services.

Par dÃ©pendances, je pense en particulier Ã :
- SystÃ¨me, programmes, libraries installÃ©s
- Configurations associÃ©es Ã  ce setup
- Volumes (fichiers)
- AccÃ¨s rÃ©seau

## Pour gÃ©rer et sÃ©curiser les connexions rÃ©seau
Car oui: c'est vite fait de faire fuiter le port d'une database, et [quand elle n'est pas sÃ©urisÃ©e c'est gÃªnant](https://www.bleepingcomputer.com/news/security/new-meow-attack-has-deleted-almost-4-000-unsecured-databases/) ğŸ˜¬

L'idÃ©e est de penser un service comme une boÃ­te noire qui expose un ou plusieurs ports. Les services communiquent entre eux grÃ¢ce aux volumes montÃ©s en commun ou Ã  travers des ports internes. En effet, les [services appartenant Ã  un mÃªme rÃ©seau](https://docs.docker.com/compose/networking/) peuvent par dÃ©faut s'accÃ©der entre eux.

## PiÃ¨ges et trucs Ã  savoir
Sous Windows et Mac, les conteneurs tournent sur une VM. Du coup c'est lent, pas natif et les lectures/Ã©critures disque peuvent ralentir l'Ã©dition de fichiers. La solution est simple: utilisez Linux ğŸ˜ (si avez une vraie solution, je serais ravi que vous la nous la partagiez ğŸ™)

Lorsqu'un mÃªme volume (dossier) est montÃ© et Ã©criture dans deux conteneurs Ã  la fois, on peut se retrouver avec des comportements inattendus: chez moi, l'intÃ©gralitÃ© du dossier gÃ©nÃ©rÃ© par un run de build disparaissait en mÃªme temps que le conteneur qui assurait le build. Je recommande donc vivement de ne monter en Ã©criture qu'une seule arborescence Ã  la fois.

C'est possible de ne partager en Ã©criture qu'une partie d'une mÃªme arborescence commune. Par exemple, si `backend` et `frontend` partagent `code` en lecture mais que `backend` doit Ã©crire dans `code/target` et `frontend` doit Ã©crire dans `code/dist`, alors les volumes peuvent Ãªtre surchargÃ©s comme ceci:
```yml
backend:
  volumes:
    - ./code:code:ro
    - ./code/target:/code/target

webapp:
  volumes:
    - ./code:code:ro
    - ./code/dist:/code/dist
```

Enfin, la gestion des permissions dÃ©routante au dÃ©but. Voir mon prochain article pour mieux comprendre pourquoi et comment bien gÃ©rer ses permissions.
