<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Nico's Lab]]></title><description><![CDATA[Experiences and thoughts of a developer who enjoys functional programming and aspires to game design.]]></description><link>https://nglab.pro</link><image><url>https://nglab.pro/icon.png</url><title>Nico&apos;s Lab</title><link>https://nglab.pro</link></image><generator>RSS for Node</generator><lastBuildDate>Thu, 08 Dec 2022 16:48:50 GMT</lastBuildDate><atom:link href="https://nglab.pro/fr/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 08 Dec 2022 16:48:50 GMT</pubDate><copyright><![CDATA[2022 Nicolas Gasull]]></copyright><language><![CDATA[fr]]></language><managingEditor><![CDATA[ng@nglab.pro]]></managingEditor><webMaster><![CDATA[ng@nglab.pro]]></webMaster><ttl>60</ttl><item><title><![CDATA[Pourquoi Docker ?]]></title><description><![CDATA[<section class="doc-section level-1"><h2 id="_pour_travailler_ensemble">Pour travailler ensemble</h2><p>Tout le monde dÃ©veloppe sur diffÃ©rentes machines. Il nâ€™est pas rare que plusieurs collÃ¨gues aient installÃ© diffÃ©rentes version dâ€™une mÃªme library, dâ€™un package manager, du runtime de leur applicationâ€¦â€‹ (cc node/npm ğŸ‘‹)</p>
<p>Lorsque lâ€™application de dÃ©veloppement est dockerisÃ©e, tous les devs (et la prod !) sont soumis aux mÃªmes rÃ¨gles, ce qui Ã©vite le syndrÃ´me de <em>"mais Ã§a marche sur mon PC"</em> tout en rÃ©duisant la configuration nÃ©cessaire Ã  installer lâ€™environnement de dev. Voir juste aprÃ¨s !</p></section>
<section class="doc-section level-1"><h2 id="_pour_moins_perdre_de_temps_Ã _configurer">Pour moins perdre de temps Ã  configurer</h2><p>La configuration, câ€™est du temps passÃ© Ã  ne pas Ãªtre productif. Plus il y a dâ€™environnements dans lesquels une application doit tourner, plus il y a de configuration Ã  faire. Docker permet dâ€™abstraire lâ€™environnement dans lequel tourne lâ€™application et donc de ne faire que le minimum nÃ©cessaire.</p>
<p>Une consÃ©quence notable : pour ajouter un service Ã  la stack, plus forcÃ©ment besoin dâ€™apprendre en dÃ©tails une technologie. Il suffit dâ€™ajouter une image existante de celle-ci, et de simplement spÃ©cifier les variables dâ€™environnement nÃ©cessaires. Par exemple, pour <a href="https://hub.docker.com/_/postgres/">ajouter une database PostgreSQL</a>, il suffit au minimum de renseigner un root password et de monter un volume pour persister les donnÃ©es.</p></section>
<section class="doc-section level-1"><h2 id="_pour_sÃ©parer_les_problÃ¨mes">Pour sÃ©parer les problÃ¨mes</h2><p>Comme chaque service est aussi simple que possible, chacun nâ€™a que trÃ¨s peu de dÃ©pendances avec le reste du monde. On voit que, par nature, les conteneurs nous poussent Ã  nâ€™avoir que le minimum vital de dÃ©pendances entre services.</p>
<p>Par dÃ©pendances, je pense en particulier Ã  :</p>
<div class="ulist"><ul><li>SystÃ¨me, programmes, libraries installÃ©es</li><li>Configurations associÃ©es Ã  ce setup</li><li>Volumes (fichiers)</li><li>AccÃ¨s rÃ©seau</li></ul></div></section>
<section class="doc-section level-1"><h2 id="_pour_gÃ©rer_et_sÃ©curiser_les_connexions_rÃ©seau">Pour gÃ©rer et sÃ©curiser les connexions rÃ©seau</h2><p>Car oui : câ€™est vite fait de faire fuiter le port dâ€™une database, et <a href="https://www.bleepingcomputer.com/news/security/new-meow-attack-has-deleted-almost-4-000-unsecured-databases/">quand elle nâ€™est pas sÃ©curisÃ©e câ€™est gÃªnant</a> ğŸ˜¬</p>
<p>Lâ€™idÃ©e est de penser un service comme une boÃ®te noire qui expose un ou plusieurs ports. Les services communiquent entre eux grÃ¢ce aux volumes montÃ©s en commun ou Ã  travers des ports internes. En effet, les <a href="https://docs.docker.com/compose/networking/">services appartenant Ã  un mÃªme rÃ©seau</a> peuvent par dÃ©faut sâ€™accÃ©der entre eux.</p></section>
<section class="doc-section level-1"><h2 id="_piÃ¨ges_et_trucs_Ã _savoir">PiÃ¨ges et trucs Ã  savoir</h2><p>Sous Windows et Mac, les conteneurs tournent sur une VM. Du coup câ€™est lent, pas natif et les lectures/Ã©critures disque peuvent ralentir lâ€™Ã©dition de fichiers. La solution est simple : utilise Linux ğŸ˜ (ou un Windows/Mac puissant)</p>
<p>Lorsquâ€™un mÃªme volume (dossier) est montÃ© en Ã©criture dans deux conteneurs Ã  la fois, on peut se retrouver avec des comportements inattendus : chez moi, lâ€™intÃ©gralitÃ© du dossier gÃ©nÃ©rÃ© par un run de build disparaissait en mÃªme temps que le conteneur Ã  la fin du run. Je recommande donc vivement de ne monter en Ã©criture quâ€™un seul fichier ou dossier Ã  la fois.</p>
<p>Câ€™est possible de ne partager en Ã©criture quâ€™une partie dâ€™une mÃªme arborescence commune. Par exemple, si <code>backend</code> et <code>frontend</code> partagent <code>code</code> en lecture mais que <code>backend</code> doit Ã©crire dans <code>code/target</code> et <code>frontend</code> doit Ã©crire dans <code>code/dist</code>, alors les volumes peuvent Ãªtre surchargÃ©s comme ceci :</p>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-yml hljs language-yaml" data-lang="yml"><span class="hljs-attr">backend:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">./code:/code:ro</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">./code/target:/code/target</span>

<span class="hljs-attr">webapp:</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">./code:/code:ro</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">./code/dist:/code/dist</span></code></pre></div>
<p>Les images Docker peuvent vite prendre de lâ€™espace disque. Mais avec le temps, la communautÃ© opte de plus en plus pour des versions minimalistes de chaque image. Autrefois avec une version <em>slim</em> de Debian, et aujourdâ€™hui souvent avec une version <a href="https://alpinelinux.org/about/">Alpine Linux</a> qui permet aux images de faire moins de 10Mo de base ! PrÃ©fÃ¨re-donc utiliser les tags <code>-alpine</code> de chaque image.</p>
<p>Enfin, la gestion des permissions est dÃ©routante au dÃ©but. Docker tourne en root par dÃ©faut et a de bonnes raisons de le faire : autant dire que jâ€™apprÃ©cie de pouvoir ouvrir les ports 80 ou 443 en dev comme en prod ğŸ™‚</p>
<p>Pour mieux comprendre pourquoi et comment bien gÃ©rer ses permissions : <a href="/fr/blog/gerer-ses-permissions-avec-docker">voir cet article</a>.</p></section>
<section class="doc-section level-1"><h2 id="_par_oÃ¹_commencer">Par oÃ¹ commencer?</h2><p>En prenant le temps de lire la doc dans lâ€™ordre, tout ne peut que bien se passer :</p>
<div class="olist arabic"><ol class="arabic"><li><a href="https://docs.docker.com/get-started/overview/">Comprends Docker</a></li><li><a href="https://docs.docker.com/compose/">Comprends docker compose</a> pour simplement faire cohabiter les services entre eux</li><li>Installe <a href="https://docs.docker.com/engine/install/">docker</a> et <a href="https://docs.docker.com/compose/install/">son plugin compose</a></li><li><a href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user">Ajoute ton user au groupe <code>docker</code></a> pour piloter le daemon sans <code>sudo</code></li><li>Câ€™est parti ! Nâ€™oublie pas de garder la configuration la plus simple possible.</li></ol></div>
<details><summary>Exemple</summary><div class="content"><p>Une stack complÃ¨te React/Rust/PostgreSQL pourrait Ãªtre lancÃ©e avec la simple config suivante Ã  la racine dâ€™un projet :</p>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-yml hljs language-yaml" data-lang="yml"><span class="hljs-attr">version:</span> <span class="hljs-string">"3"</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">db:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:alpine</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=yolo</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./db/data:/var/lib/postgresql/data</span>
  <span class="hljs-attr">backend:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">rust:slim</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PGHOST=db</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PGDATABASE=monservice</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PGUSER=root</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PGPASSWORD=yolo</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./backend/:/home/backend</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./webapp/:/home/webapp:ro</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">cargo</span> <span class="hljs-string">run</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">4000</span><span class="hljs-string">:4000</span>
  <span class="hljs-attr">webapp:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">node:alpine</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">BACKEND_URL=http://backend:4000/</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./webapp/:/home/webapp</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">sh</span> <span class="hljs-string">-c</span> <span class="hljs-string">"yarn install &amp;&amp; CI=true yarn start"</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:8080</span></code></pre></div>
<p><code>docker compose up -d</code> et câ€™est parti directement sur <a href="http://localhost">localhost</a> ! ğŸ’»</p></div></details></section>]]></description><link>https://nglab.pro/pourquoi-docker</link><guid isPermaLink="true">https://nglab.pro/pourquoi-docker</guid><category><![CDATA[devops]]></category><dc:creator><![CDATA[Nicolas Gasull]]></dc:creator><pubDate>Thu, 06 Aug 2020 00:00:00 GMT</pubDate></item><item><title><![CDATA[GÃ©rer ses permissions avec Docker]]></title><description><![CDATA[<section id="preamble" aria-label="Preamble"><p>Tout dâ€™abord soyons dâ€™accord sur les mots :</p>
<div class="ulist"><ul><li>L'<strong><em>hÃ´te</em></strong> est le systÃ¨me dâ€™exploitation de la machine, celui qui fait tourner Docker lui-mÃªme</li><li>Nous utiliserons <strong><em>conteneur</em></strong> pour se rÃ©fÃ©rer Ã  ce qui est exÃ©cutÃ© dans lâ€™univers de Docker</li><li>Les <strong><em>user namespaces</em></strong>, que jâ€™appellerai <strong><em>subuids</em></strong>, sont une fonctionnalitÃ© native Unix pour faire correspondre les ids dâ€™utilisateurs systÃ¨me vers une page dâ€™utilisateurs donnÃ©e.</li></ul></div>
<p>Lâ€™article dÃ©crit comment utiliser les user namespaces (<em>subuids</em>) dans un environnement Unix pour rÃ©server une plage dâ€™utilisateurs au daemon Docker. Il est probable que Docker for Mac supporte cette fonctionnalitÃ©.</p></section>
<nav id="toc" class="toc" role="doc-toc"><h2 id="toc-title">Table des matiÃ¨res</h2><ol class="toc-list level-1"><li><a href="#_motivation">Motivation</a></li><li><a href="#_mise_en_place">Mise en place</a><ol class="toc-list level-2"><li><a href="#_mappings_de_dev">Mappings de dev</a></li><li><a href="#_mappings_de_ciproduction">Mappings de CI/production</a></li></ol></li><li><a href="#_problÃ¨mes_et_trucs_Ã _savoir">ProblÃ¨mes et trucs Ã  savoir</a></li></ol></nav>
<section class="doc-section level-1"><h2 id="_motivation">Motivation</h2><p>Sur lâ€™hÃ´te, sans configuration donnÃ©e, les fichiers manipulÃ©s par Docker appartiennent au mÃªme utilisateur que celui du conteneur. Ce nâ€™est pas rassurant dans le sens oÃ¹ le daemon Docker tourne en <code>root</code> par dÃ©faut et que les conteneurs ne sont pas tenus de sâ€™exÃ©cuter en tant que lâ€™utilisateur qui leur a Ã©tÃ© donnÃ© en configuration.</p>
<figure class="example-block"><figcaption>Exemple :</figcaption>
<div class="example">Les images <code>postgres</code> et <code>mysql</code> Ã©crivent dâ€™elles-mÃªmes une partie de leurs fichiers avec les les utilisateurs de PostgreSQL et MySQL.</div></figure>
<p>Pour Ã©viter ce problÃ¨me, nous allons indiquer au daemon Docker Ã  quels utilisateurs hÃ´te correspondent tous les utilisateurs des conteneurs.</p></section>
<section class="doc-section level-1"><h2 id="_mise_en_place">Mise en place</h2><h5 id="_configuration_hÃ´te_impactÃ©e" class="discrete">Configuration hÃ´te impactÃ©e :</h5>
<div class="ulist"><ul><li><code>/etc/subuid</code> - configuration des mappings utilisateur hÃ´te â‡â‡’ conteneur</li><li><code>/etc/subgid</code> - configuration des mappings groupe hÃ´te â‡â‡’ conteneur</li><li><code>/etc/docker/daemon.json</code> - configuration du daemon Docker</li></ul></div>
<p>Selon moi, câ€™est avantageux de configurer diffÃ©remment ces mappings sur les machines des dÃ©veloppeurs et en CI/production. En effet : autant tirer profit de cette flexibilitÃ© pour dÃ©velopper confortablement tout en gardant la production sous contrÃ´le.</p>
<section class="doc-section level-2"><h3 id="_mappings_de_dev">Mappings de dev</h3><p>En mappant le <code>root</code> des conteneurs vers ton utilisateur hÃ´te, tu peux simplement profiter dâ€™une transparence de permissions par dÃ©faut. Plus de problÃ¨mes avec les volumes gÃ©nÃ©rÃ©s en <code>root</code> hÃ´te puis crashant lâ€™exÃ©cution Ã  cause de la mauvaise permission !</p>
<p>Pour ma part, je map simplement <code>root</code> vers mon user hÃ´te puis tous les autres uids 1+ vers 100001+ sur lâ€™hÃ´te.</p>
<p>La seule chose Ã  confirmer : lâ€™id de ton utilisateur hÃ´te. Câ€™est souvent 1000 et câ€™est vÃ©rifiable en exÃ©cutant <code>id -u</code>.</p>
<h5 id="_etcsubuid" class="discrete">/etc/subuid</h5>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-none hljs">dockremap:1000:1
dockremap:100001:65536</code></pre></div>
<h5 id="_explication" class="discrete">Explication</h5>
<p>Un mapping nommÃ© <code>dockremap</code> est crÃ©Ã© :</p>
<div class="ulist"><ul><li><em>1e ligne :</em> assigne 1 utilisateur (de conteneur pour nous) vers lâ€™uid 1000. Ce 1e utilisateur est lâ€™utilisateur 0, donc <code>root</code>.</li><li><em>2e ligne :</em> assigne les 65536 prochains utilisateurs vers la plage commenÃ§ant par 100001, donc vers 100001-165536. Par exemple, lâ€™utilisateur conteneur 66 sera manipulÃ© sur lâ€™hÃ´te comme Ã©tant lâ€™utilisateur 100066.</li></ul></div>
<p>Je pense quâ€™appliquer le mÃªme principe pour les groupes est tout aussi profitable : la transparence est totale. On peut vÃ©rifier son <code>gid</code> avec <code>id -g</code>.</p>
<h5 id="_etcsubgid" class="discrete">/etc/subgid</h5>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-none hljs">dockremap:1000:1
dockremap:100001:65536</code></pre></div>
<h5 id="_etcdockerdaemon_json" class="discrete">/etc/docker/daemon.json</h5>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"userns-remap"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dockremap"</span>
<span class="hljs-punctuation">}</span></code></pre></div>
<p>Nâ€™oublie pas de redÃ©marrer le daemon docker pour que cela prenne effet ğŸ˜‰</p>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">sudo service docker restart</code></pre></div></section>
<section class="doc-section level-2"><h3 id="_mappings_de_ciproduction">Mappings de CI/production</h3><p>En production, la configuration dÃ©pend davantage des permissions que tu veux donner Ã  tes conteneurs. On est davantage sur des problÃ©matiques de sÃ©curitÃ© que de praticitÃ©.</p>
<p>Il est possible dâ€™appliquer le mÃªme type de configuration que prÃ©cÃ©demment Ã  condition de bien connaÃ®tre les consÃ©quences du mapping, en particulier pour lâ€™utilisateur 0.</p></section></section>
<section class="doc-section level-1"><h2 id="_problÃ¨mes_et_trucs_Ã _savoir">ProblÃ¨mes et trucs Ã  savoir</h2><p>Il est possible de mapper plusieurs utilisateurs spÃ©cifiques conteneur vers des utilisateurs spÃ©cifiques hÃ´te. Par exemple :</p>
<div class="listing-block"><pre class="highlightjs highlight"><code class="language-none hljs">dockremap:1000:1
dockremap:100001:65
dockremap:666:1
dockremap:100067:65469</code></pre></div>
<p>Ce qui peut se lire : map 0 conteneur vers 1000 hÃ´te, map les 65 utilisateurs suivants sur la plage hÃ´te commenÃ§ant par 100001, map le suivant (66) vers 666 sur lâ€™hÃ´te, map le reste sur la plage hÃ´te commenÃ§ant par 100067.</p>
<hr>
<p>Jâ€™espÃ¨re que cet article tâ€™aura Ã©clairÃ© sur lâ€™utilisation des <em>user namespaces</em> pour gÃ©rer ses permissions Docker. Il sâ€™agit dâ€™un retour dâ€™expÃ©rience personnelle et de mes avis sur le sujet. Nâ€™hÃ©site pas Ã  explorer par toi-mÃªme, faire ta propre configuration et <a href="/fr/about/">me la partager</a> ğŸ™‚</p></section>]]></description><link>https://nglab.pro/gerer-ses-permissions-avec-docker</link><guid isPermaLink="true">https://nglab.pro/gerer-ses-permissions-avec-docker</guid><category><![CDATA[devops]]></category><dc:creator><![CDATA[Nicolas Gasull]]></dc:creator><pubDate>Tue, 01 Sep 2020 00:00:00 GMT</pubDate></item></channel></rss>