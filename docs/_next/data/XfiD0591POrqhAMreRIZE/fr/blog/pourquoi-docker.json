{"pageProps":{"locale":"fr","scope":{"date":"2020-08-06","slug":"pourquoi-docker","lang":"fr","title":"Pourquoi Docker ?","html":"<section class=\"doc-section level-1\"><h2 id=\"_pour_travailler_ensemble\">Pour travailler ensemble</h2><p>Tout le monde dÃ©veloppe sur diffÃ©rentes machines. Il nâ€™est pas rare que plusieurs collÃ¨gues aient installÃ© diffÃ©rentes version dâ€™une mÃªme library, dâ€™un package manager, du runtime de leur applicationâ€¦â€‹ (cc node/npm ğŸ‘‹)</p>\n<p>Lorsque lâ€™application de dÃ©veloppement est dockerisÃ©e, tous les devs (et la prod !) sont soumis aux mÃªmes rÃ¨gles, ce qui Ã©vite le syndrÃ´me de <em>\"mais Ã§a marche sur mon PC\"</em> tout en rÃ©duisant la configuration nÃ©cessaire Ã  installer lâ€™environnement de dev. Voir juste aprÃ¨s !</p></section>\n<section class=\"doc-section level-1\"><h2 id=\"_pour_moins_perdre_de_temps_Ã _configurer\">Pour moins perdre de temps Ã  configurer</h2><p>La configuration, câ€™est du temps passÃ© Ã  ne pas Ãªtre productif. Plus il y a dâ€™environnements dans lesquels une application doit tourner, plus il y a de configuration Ã  faire. Docker permet dâ€™abstraire lâ€™environnement dans lequel tourne lâ€™application et donc de ne faire que le minimum nÃ©cessaire.</p>\n<p>Une consÃ©quence notable : pour ajouter un service Ã  la stack, plus forcÃ©ment besoin dâ€™apprendre en dÃ©tails une technologie. Il suffit dâ€™ajouter une image existante de celle-ci, et de simplement spÃ©cifier les variables dâ€™environnement nÃ©cessaires. Par exemple, pour <a href=\"https://hub.docker.com/_/postgres/\">ajouter une database PostgreSQL</a>, il suffit au minimum de renseigner un root password et de monter un volume pour persister les donnÃ©es.</p></section>\n<section class=\"doc-section level-1\"><h2 id=\"_pour_sÃ©parer_les_problÃ¨mes\">Pour sÃ©parer les problÃ¨mes</h2><p>Comme chaque service est aussi simple que possible, chacun nâ€™a que trÃ¨s peu de dÃ©pendances avec le reste du monde. On voit que, par nature, les conteneurs nous poussent Ã  nâ€™avoir que le minimum vital de dÃ©pendances entre services.</p>\n<p>Par dÃ©pendances, je pense en particulier Ã  :</p>\n<div class=\"ulist\"><ul><li>SystÃ¨me, programmes, libraries installÃ©es</li><li>Configurations associÃ©es Ã  ce setup</li><li>Volumes (fichiers)</li><li>AccÃ¨s rÃ©seau</li></ul></div></section>\n<section class=\"doc-section level-1\"><h2 id=\"_pour_gÃ©rer_et_sÃ©curiser_les_connexions_rÃ©seau\">Pour gÃ©rer et sÃ©curiser les connexions rÃ©seau</h2><p>Car oui : câ€™est vite fait de faire fuiter le port dâ€™une database, et <a href=\"https://www.bleepingcomputer.com/news/security/new-meow-attack-has-deleted-almost-4-000-unsecured-databases/\">quand elle nâ€™est pas sÃ©curisÃ©e câ€™est gÃªnant</a> ğŸ˜¬</p>\n<p>Lâ€™idÃ©e est de penser un service comme une boÃ®te noire qui expose un ou plusieurs ports. Les services communiquent entre eux grÃ¢ce aux volumes montÃ©s en commun ou Ã  travers des ports internes. En effet, les <a href=\"https://docs.docker.com/compose/networking/\">services appartenant Ã  un mÃªme rÃ©seau</a> peuvent par dÃ©faut sâ€™accÃ©der entre eux.</p></section>\n<section class=\"doc-section level-1\"><h2 id=\"_piÃ¨ges_et_trucs_Ã _savoir\">PiÃ¨ges et trucs Ã  savoir</h2><p>Sous Windows et Mac, les conteneurs tournent sur une VM. Du coup câ€™est lent, pas natif et les lectures/Ã©critures disque peuvent ralentir lâ€™Ã©dition de fichiers. La solution est simple : utilise Linux ğŸ˜ (ou un Windows/Mac puissant)</p>\n<p>Lorsquâ€™un mÃªme volume (dossier) est montÃ© en Ã©criture dans deux conteneurs Ã  la fois, on peut se retrouver avec des comportements inattendus : chez moi, lâ€™intÃ©gralitÃ© du dossier gÃ©nÃ©rÃ© par un run de build disparaissait en mÃªme temps que le conteneur Ã  la fin du run. Je recommande donc vivement de ne monter en Ã©criture quâ€™un seul fichier ou dossier Ã  la fois.</p>\n<p>Câ€™est possible de ne partager en Ã©criture quâ€™une partie dâ€™une mÃªme arborescence commune. Par exemple, si <code>backend</code> et <code>frontend</code> partagent <code>code</code> en lecture mais que <code>backend</code> doit Ã©crire dans <code>code/target</code> et <code>frontend</code> doit Ã©crire dans <code>code/dist</code>, alors les volumes peuvent Ãªtre surchargÃ©s comme ceci :</p>\n<div class=\"listing-block\"><pre class=\"highlightjs highlight\"><code class=\"language-yml hljs language-yaml\" data-lang=\"yml\"><span class=\"hljs-attr\">backend:</span>\n  <span class=\"hljs-attr\">volumes:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./code:/code:ro</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./code/target:/code/target</span>\n\n<span class=\"hljs-attr\">webapp:</span>\n  <span class=\"hljs-attr\">volumes:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./code:/code:ro</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./code/dist:/code/dist</span></code></pre></div>\n<p>Les images Docker peuvent vite prendre de lâ€™espace disque. Mais avec le temps, la communautÃ© opte de plus en plus pour des versions minimalistes de chaque image. Autrefois avec une version <em>slim</em> de Debian, et aujourdâ€™hui souvent avec une version <a href=\"https://alpinelinux.org/about/\">Alpine Linux</a> qui permet aux images de faire moins de 10Mo de base ! PrÃ©fÃ¨re-donc utiliser les tags <code>-alpine</code> de chaque image.</p>\n<p>Enfin, la gestion des permissions est dÃ©routante au dÃ©but. Docker tourne en root par dÃ©faut et a de bonnes raisons de le faire : autant dire que jâ€™apprÃ©cie de pouvoir ouvrir les ports 80 ou 443 en dev comme en prod ğŸ™‚</p>\n<p>Pour mieux comprendre pourquoi et comment bien gÃ©rer ses permissions : <a href=\"/fr/blog/gerer-ses-permissions-avec-docker\">voir cet article</a>.</p></section>\n<section class=\"doc-section level-1\"><h2 id=\"_par_oÃ¹_commencer\">Par oÃ¹ commencer?</h2><p>En prenant le temps de lire la doc dans lâ€™ordre, tout ne peut que bien se passer :</p>\n<div class=\"olist arabic\"><ol class=\"arabic\"><li><a href=\"https://docs.docker.com/get-started/overview/\">Comprends Docker</a></li><li><a href=\"https://docs.docker.com/compose/\">Comprends docker compose</a> pour simplement faire cohabiter les services entre eux</li><li>Installe <a href=\"https://docs.docker.com/engine/install/\">docker</a> et <a href=\"https://docs.docker.com/compose/install/\">son plugin compose</a></li><li><a href=\"https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user\">Ajoute ton user au groupe <code>docker</code></a> pour piloter le daemon sans <code>sudo</code></li><li>Câ€™est parti ! Nâ€™oublie pas de garder la configuration la plus simple possible.</li></ol></div>\n<details><summary>Exemple</summary><div class=\"content\"><p>Une stack complÃ¨te React/Rust/PostgreSQL pourrait Ãªtre lancÃ©e avec la simple config suivante Ã  la racine dâ€™un projet :</p>\n<div class=\"listing-block\"><pre class=\"highlightjs highlight\"><code class=\"language-yml hljs language-yaml\" data-lang=\"yml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">\"3\"</span>\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">postgres:alpine</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_PASSWORD=yolo</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./db/data:/var/lib/postgresql/data</span>\n  <span class=\"hljs-attr\">backend:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">rust:slim</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PGHOST=db</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PGDATABASE=monservice</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PGUSER=root</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PGPASSWORD=yolo</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./backend/:/home/backend</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./webapp/:/home/webapp:ro</span>\n    <span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">cargo</span> <span class=\"hljs-string\">run</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">4000</span><span class=\"hljs-string\">:4000</span>\n  <span class=\"hljs-attr\">webapp:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">node:alpine</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">BACKEND_URL=http://backend:4000/</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./webapp/:/home/webapp</span>\n    <span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">sh</span> <span class=\"hljs-string\">-c</span> <span class=\"hljs-string\">\"yarn install &amp;&amp; CI=true yarn start\"</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">80</span><span class=\"hljs-string\">:8080</span></code></pre></div>\n<p><code>docker compose up -d</code> et câ€™est parti directement sur <a href=\"http://localhost\">localhost</a> ! ğŸ’»</p></div></details></section>","categories":["devops"]}},"__N_SSG":true}